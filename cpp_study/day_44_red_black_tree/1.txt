1.二叉搜索树 -> 存储数据的同时方便进行高效搜索
问题:极端情况下(比如有序的方式进行插入),二叉搜索树就会退化成单链形式,效率变成O(N)
效率低下
2.AVLTree -> 在二叉搜索树的基础之上加了一个条件:左右子树高度差不超过1，并且左右子树也满足次条件(也就是说所有子树都满足)
增删查改搜索效率非常高:
高度平衡二叉树 (如果内存足够的情况下，将所有中国人的信息放在树中，查找一个人的信息最多只需要31次,如果是暴力搜索需要14亿次)
3.红黑树 几乎顶替掉了avltree的地位

复习一下AVLTree:
1.增，删，查，改;  查，改借助find来实现
增:a.按搜索树的规则插入 b.更新平衡因子 c.如果出现平衡因子位2或者-2 ，则根据情况判断是哪种旋转，进行旋转 左单旋 右单旋 左右单旋 右左单旋
删:a.按搜索树的规则删除 b.更新平衡因子 c.更新过程中出现平衡因子为 2 或者 -2，则根据情况判断是哪种旋转，进行旋转处理 

插入 右边插入 父亲平衡因子++,左边插入 父亲平衡因子--
删除 右边删除 父亲平衡因子--，左边删除 父亲平衡因子++

插入后父亲的平衡因子变为0，说明,父亲所在树高度不变，更新结束
删除后父亲的平衡因子变为0，说明,父亲所在树高度改变，更新继续

插入后，父亲的平衡因子变成1/-1，说明父亲所在的树的高度变了，继续往上更新
删除后，父亲的平衡因子变成1/-1，说明父亲所在的树的高度不变，更新结束

插入/删除后,父亲的平衡因子变成2/-2,说明不平衡，旋转处理

查和改:
1.搜索树中key是不允许修改的,因为如果修改了整棵树可能就破坏了。key/value 的场景下可以删除value
2.查和改和二叉搜索树是一样的。

红黑树:
1.搜索二叉树,节点中加了颜色,不是红色就是黑色,长的路径不超过短的路径的两倍。

AVL树是严格二叉搜索树
红黑树是近似平衡二叉搜索树


总结一下：a.根是黑的 b.没有连续的红节点 c.每条路径都有相同数量的黑节点
最短的路径：全黑
最长的路径：一黑一红
所以最多是2倍

增删查改的时间复杂度是多少
就是说理论上而言，红黑树的效率比avl树略差
但是现在呢，硬件的运算速度非常快，他们之间已经基本没有差异了。因为常规数据集中logn足够小，2*logn差异不大

但是插入删除同样节点红黑树比avltree旋转更少，因为avltree更严格的平衡其实是通过多旋转达到的


每个节点要么是红色，要么是黑色
每个节点都有一个颜色属性，红或黑，这是红黑树的基本特性。

根节点必须是黑色
红黑树的根节点始终为黑色，以确保树的整体平衡性。

每个叶子节点（空节点）都是黑色
在红黑树的实现中，叶子节点通常是 NULL 或哨兵节点，它们都被认为是黑色。

红色节点的子节点必须是黑色（不能有连续的红色节点）
也称为 红节点的父节点和子节点不能都是红色，这避免了长路径的不平衡。

从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点
也称为 黑高一致性，这是红黑树平衡的核心条件，确保路径长度不会有过大的差异。