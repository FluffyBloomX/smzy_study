1.二叉搜索树 -> 存储数据的同时方便进行高效搜索
问题:极端情况下(比如有序的方式进行插入),二叉搜索树就会退化成单链形式,效率变成O(N)
效率低下
2.AVLTree -> 在二叉搜索树的基础之上加了一个条件:左右子树高度差不超过1，并且左右子树也满足次条件(也就是说所有子树都满足)
增删查改搜索效率非常高:
高度平衡二叉树 (如果内存足够的情况下，将所有中国人的信息放在树中，查找一个人的信息最多只需要31次,如果是暴力搜索需要14亿次)
3.红黑树 几乎顶替掉了avltree的地位

复习一下AVLTree:
1.增，删，查，改;  查，改借助find来实现
增:a.按搜索树的规则插入 b.更新平衡因子 c.如果出现平衡因子位2或者-2 ，则根据情况判断是哪种旋转，进行旋转 左单旋 右单旋 左右单旋 右左单旋
删:a.按搜索树的规则删除 b.更新平衡因子 c.更新过程中出现平衡因子为 2 或者 -2，则根据情况判断是哪种旋转，进行旋转处理 